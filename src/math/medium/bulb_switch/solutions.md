> 解法一：暴力循环

使用一个长度为 `n` 的 `boolean` 数组，全部初始化为 `false`，每遍历到一次就反转对应的值，最后统计为 `true`的个数

**参考代码：**

```java
public int bulbSwitch(int n) {
    boolean[] sta = new boolean[n];
    for (int i = 1; i <= n; i++) {
        for (int j = i-1; j < sta.length; ) {
            sta[j] = !sta[j];
            j += i;
        }
        // System.out.println(n+" : "+Arrays.toString(sta));
    }
    int res = 0;
    for (boolean b : sta) {
        if (b) {
            res++;
        }
    }
    return res;
}
```

$$
\begin{cases} 时间复杂度：O(n^2)，需要循环两次\\\\空间复杂度：O(n)，使用长度为 n 的数组保存中间结果 \end{cases}
$$



> 解法二：数学

先放出`0 - 20`的结果，其中 `1`表示灯亮的状态

```xml
第 0  轮结果 : []
第 1  轮结果 : [1]
第 2  轮结果 : [1, 0]
第 3  轮结果 : [1, 0, 0]
第 4  轮结果 : [1, 0, 0, 1]
第 5  轮结果 : [1, 0, 0, 1, 0]
第 6  轮结果 : [1, 0, 0, 1, 0, 0]
第 7  轮结果 : [1, 0, 0, 1, 0, 0, 0]
第 8  轮结果 : [1, 0, 0, 1, 0, 0, 0, 0]
第 9  轮结果 : [1, 0, 0, 1, 0, 0, 0, 0, 1]
第 10 轮结果 : [1, 0, 0, 1, 0, 0, 0, 0, 1, 0]
第 11 轮结果 : [1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0]
第 12 轮结果 : [1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0]
第 13 轮结果 : [1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0]
第 14 轮结果 : [1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]
第 15 轮结果 : [1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]
第 16 轮结果 : [1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1]
第 17 轮结果 : [1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0]
第 18 轮结果 : [1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0]
第 19 轮结果 : [1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]
第 20 轮结果 : [1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]
```

不难看出，当`n`可以被完全开平方时，第一个灯和最后一个灯都是亮着的，所以从 **找规律** 的角度来看，结果就是对 `n` 开平方。

**LeetCode 官方解答为：**

如果我们将所有的灯泡从左到右依次编号为 1, 2, $\cdots$, $n$ ，那么可以发现：

在第 `i` 轮时，我们会将所有编号为 `i` 的倍数的灯泡进行切换。

因此，对于第 `k` 个灯泡，它被切换的次数恰好就是 `k` 的约数个数。如果 `k` 有偶数个约数，那么最终第 `k` 个灯泡的状态为暗；如果 `k` 有奇数个约数，那么最终第 `k` 个灯泡的状态为亮。

对于 `k` 而言，如果它有约数 `x`，那么一定有约数 $\dfrac{k}{x}$  。因此只要当 $x^2 \neq kx $ 时，约数都是「成对」出现的。这就说明，只有当 `k` 是「完全平方数」时，它才会有奇数个约数，否则一定有偶数个约数。

因此我们只需要找出 1, 2, $\cdots$, $n$ 中的完全平方数的个数即可，答案即为 $\lfloor \sqrt{n} \rfloor$，其中 $\lfloor \cdot \rfloor$表示向下取整。

**细节：**由于 $\sqrt{n}$ 涉及到浮点数运算，为了保证不出现精度问题，我们可以计算 $\sqrt{n + \dfrac{1}{2}}$，这样可以保证计算出来的结果向下取整在 3232 位整数范围内一定正确。

**参考代码：**

```java
public int bulbSwitch2(int n) {
    return (int) Math.sqrt(n+0.5);
}
```


$$
\begin{cases} 时间复杂度：O(1)\\\\空间复杂度：O(1) \end{cases}
$$


> 作者：LeetCode-Solution
> 链接：https://leetcode-cn.com/problems/bulb-switcher/solution/deng-pao-kai-guan-by-leetcode-solution-rrgp/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。